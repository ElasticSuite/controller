{"name":"controller","body":"## Welcome to controller.\r\n**controller** is a [Dojo Toolkit](http://dojotoolkit.org/) based package that is designed to provide some intelligence to bridge the gap between application logic and the user interface representation of that logic.  It is a package where its modules fit alongside a Dojo distribution.  It is has the following modules:\r\n\r\n### controller/command/Command\r\n\r\nThis class is designed to encapsulate a piece of code which can be `.execute()` and potentially `.undo()`.\r\n\r\n### controller/command/CompoundCommand\r\n\r\nThis class is designed combine multiple commands into a single command.\r\n\r\n### controller/command/CommandStack\r\n\r\nThis class is designed to allow `Command`s to be `.execute()`, `.undo()` and `.redo()` in a ordered stack.  This provides the logic to enable an \"undo\"/\"redo\" history, where each `Command` executed by the `CommandStack` will be pushed onto the stack.  You can also `.jump()` to a particular point in the stack.\r\n\r\n### controller/action/Action\r\n\r\nThis is the \"bridge\" between a visual widget and code.  `Action`s are designed to be `.bind()` to widgets.  Once bound, properties of the `Action` will be propagated to the widget and when the widget is \"actioned\" (usually when it is clicked) the `Action` will `.run()`.  If the `Action` is assigned a `Command` it will be `.execute()` and if there is also a `CommandStack` it will be pushed onto the `CommandStack` to provide the \"undo/redo\" functionality.\r\n\r\n`Action` can be instantiated itself, or subclassed for further modification.\r\n\r\n### Notes\r\n\r\nAll of the classes are built upon `dojo/Stateful` and `dojo/Evented`.  This gives them the support for both robust property features including `.set()`, `.get()` and `.when()` as well as the classes emit events as appropriate.","tagline":"Commands and Action Abstractions for Dojo","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}